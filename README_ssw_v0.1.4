SSW: Striped Smith-Waterman Sequence Alignment Algorithm

Author: Mengyao Zhao, Ph.D. student of Boston College
Last revision: 06/24/2011

1. Overview
SSW is a fast implementation of the Smith-Waterman algorithm, which use the Single-Instruction Multiple-Data (SIMD) instructions 
to parallelize the algorithm at the instruction level. The SIMD registers are parallel to the query sequence, but are accessed in 
a striped pattern. The query profile is calculated once for the database search, but the conditional F matrix adjustment and the 
best lignment location tracing are moved outside the inner loop for achieving high performance [1][2]. Current version is ~90 times
faster than the Smith-Waterman in Mozaik and can return optimal and sub-optimal alignment locations.

2. Input and output
The input files to SSW are: (1) a FASTA format reference sequence file; (2) a FASTA or FASTQ format read sequence file.

The output of SSW reports the optimal and sub_optimal alignment scores and alignment ending positions of each read in the read file
to each reference in the reference file.

An example of the output:
...
read_name: 1:57651555:R:-316;None;None/1
read_seq: AGACTTGAAAGTCAGAATTACTCCTTGATCCATGGGCTGCAGAGTAGATGTTTT
max score: 41, end_ref: 530
max2 score: 39, end_ref: 499
read_name: X:91671697:R:-206;None;X,91671506,G,A/1
read_seq: ACTTCTTTGGTTCAAAGGTTTCTTTTCTTTTCATCAGAGTATTTTGAATCACTT
max score: 54, end_ref: 523
max2 score: 40, end_ref: 494
...

3. Software information
SSW was developed in the pure C programming language. It is distributed for the Microsoft Windows, Mac OS X and Linux operating systems.

4. Usage
Linux: ./ssw_test <references.fasta> <reads.fasta>/<reads.fastq>

useful structures and functions:

/*! @typedef	struct of the alignment results
 *  @field score	the alignment score
 *	@field	ref	1-based position in the reference
 */
typedef struct {
	char score;
	int32_t ref;	/* 1-based position */
} alignment_end;

/*! @function	Generate query profile rearrange query sequence & calculate the weight of match/mismatch. 
 *  @parameter	read	sequence
 *  @parameter	weight_match	score for a pair of matched reference and read bases
 *  @parameter	weight_mismatch	score (absolute value) for a pair of mismached reference and read bases
 *	@parameter	bias	a number used to expend the max capacity of the values in the scoreing matrix; suggest to set to 4
 *  @return		pointer to the query profile 
 */
__m128i* queryProfile_constructor (const char* read,
								   unsigned char weight_match,    /* will be used as + */
								   unsigned char weight_mismatch, /* will be used as - */
								   unsigned char bias);

/*! @function	Transform the reference sequence to a number sequence. 
 *	@parameter	ref	reference sequence
 *	@parameter	refLen	reference length
 *	@return		reference sequence represented by numbers
 */
int32_t* ref_nt2num (const char* ref, int32_t refLen);

/*! @function	striped Smith-Waterman
 *  			Record the highest score of each reference position. 
 *  			Find the ending position of the optimal and sub-optimal alignment.
 *  @parameter	ref	reference sequence represented by numbers; can be generated using funceion ref_nt2num
 *  @parameter	refLen	reference length
 *  @parameter	readLen	read length
 *  @parameter	weight_insertB	score (absolute value) for opening a insertion 
 *  @parameter	weight_insertE	score (absolute value) for extending a insertion 
 *  @parameter	weight_deletB	score (absolute value) for opening a deletion 
 *  @parameter	weight_deletE	score (absolute value) for extending a deletion 
 *  @parameter	vProfile	pointer to the query profile
 *  @parameter	end_seg	a return value of 0-based segment number of alignment ending position in read; suggest to set to 0
 *	@parameter	bias	a number used to expend the max capacity of the values in the scoreing matrix; suggest to set to 4
 *  @return		a pointer to the array of structure alignment_end; the optimal (1st member of the array) and 
 *				sub-optimal (2nd member of the array) alignment score and ending positions
 */
alignment_end* smith_waterman_sse2 (const int32_t* ref,
									int32_t refLen,
								    int32_t readLen, 
								    unsigned char weight_insertB, /* will be used as - */
								    unsigned char weight_insertE, /* will be used as - */
								    unsigned char weight_deletB,  /* will be used as - */
								    unsigned char weight_deletE,  /* will be used as - */
								    __m128i* vProfile,
								    int32_t* end_seg,        /* 0-based segment number of ending   
																	 alignment; The return value is  
																	 meaningful only when  
																     the return value != 0.
																   */	
	 							    unsigned char bias);	

example of using the functions: main.c

5. Speed and memory usage
The time complexity of SSW is Omn. Where m is the reference length, n is the read length. SSW implementation divides the 128-bit
wide register into 16 8-bit elements for parallel processing. Therefore, the runtime of SSW is theoretically 1/16 of original
Smith-Waterman algorithm, thus 1/16mn. Due to the advantage of Intel's SIMD SSE2 instuctions, the actual runtime of SSW is 
even shorter, about 90 times faster than original Smith-Waterman algorithm.

Speed test result of ssw_v0.1.4 on 100 Illumina 54 bp reads:
Reference length	CPU time (s)
1K	0.008719			
10K	0.060667
100K	0.571767	
1M	5.677395
10M	55.117683		

The space complexity of SSW is On. The runtime maximum RAM usage is n bytes. Where n is the read length.

References
1. Farrar, M. Striped Smith-Waterman speeds database searches six times over other SIMD implementations. Bioinformatics 23, 156-161. (2007).
2. Hinton, G. et al. The microarchitecture of the Pentium 4 Processor. Intel Technology Journal Q1 (2001). 



